<!DOCTYPE html> 
   <!-- The previous line tells the browser, that the page uses the HTML5 standard. --> 
    
   <html>
       <head>
           <title>Three.js tutorial - Lesson 04</title> 
           <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"> 
    
           <!-- The following meta line optimizes the site for mobile devices. It sets the viewport size 
          to the screen size, so it will be displayed maximized, but unscaled. --> 
          <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"> 
          <style type="text/css"> 
              body { 
                  /* Set the background color of the HTML page to black */ 
                  background-color: #000000; 
   
                  /* Hide oversized content. This prevents the scroll bars. */ 
                  overflow: hidden; 
              } 
          </style> 
          <!-- Include Three.js libraries --> 
		  <script src = "http://threejs.org/build/three.min.js"></script>
		<script src = "Detector.js"></script> <! one can ask this condition on the site face as well.>
		<script src = "GeneratorRoberta.js"></script>
          <!script src="../js/r69/three.js"></script> 
          <!script src="../js/r69/Detector.js"></script> 
          <!script src="../js/r69/CanvasRenderer.js"></script> 
          <!script src="../js/r69/Projector.js"></script> 
		  <!script src = "CanvasRenderer.js"></script>
      </head> 
      <body>
          <!-- This is the DIV element which will contain the WebGL canvas. To be identifiable lateron, 
          the id 'WebGLCanvas' is applied to it. --> 
          <div id="WebGLCanvas"> 
   
          <!-- This JavaScript block encloses the Three.js commands --> 
          <script> 
            // code for adding a new canvas
			/**	var canvas = document.createElement("canvas");
				var context = canvas.getContext("2d");
			  
			   var image0 = new Image();
				var texture = new THREE.Texture(canvas);
				
				
				
				image0.onload = function() {
				context.drawImage(image0, 0, 0);
				texture.needsUpdate = true;
				};
				image0.src = 'playground.jpg';
			  */
			  
			  // Global scene object 
              var scene; 
   
              // Global camera object  
              var camera; 
   
              
              // Global mesh object of the square 
              var squareMesh; 
			  var triMesh ;
			  var lightSensoMesh;
			  var skyBox ;
   
			  var myMotion ;
			  var distance ;
              // Initialize the scene 
              initializeScene(); 
   
              // Instead of calling 'renderScene()', we call a new function: 'animateScene()'. It will 
              // update the rotation values and call 'renderScene()' in a loop. 
   
              // Animate the scene 
              animateScene(); 
   
              /** 
               * Initialze the scene. 
               */ 
              function initializeScene(){ 
                  // Check whether the browser supports WebGL. If so, instantiate the hardware accelerated 
                  // WebGL renderer. For antialiasing, we have to enable it. The canvas renderer uses 
                  // antialiasing by default. 
                  // The approach of multiplse renderers is quite nice, because your scene can also be 
                  // viewed in browsers, which don't support WebGL. The limitations of the canvas renderer 
                  // in contrast to the WebGL renderer will be explained in the tutorials, when there is a 
                  // difference. 
                 // if(Detector.webgl){ 
                   //   renderer = new THREE.WebGLRenderer({antialias:true}); 
   
                  // If its not supported, instantiate the canvas renderer to support all non WebGL 
                  // browsers 
                  //} else { 
                      renderer = new THREE.CanvasRenderer(); 
                  //} 
   
                  // Set the background color of the renderer to black, with full opacity 
                  renderer.setClearColor(0x000000, 1); 
  
                  // Get the size of the inner window (content area) to create a full size renderer 
                  canvasWidth = window.innerWidth; 
                  canvasHeight = window.innerHeight; 
   
                // Set the renderers size to the content areas size 
                  renderer.setSize(canvasWidth, canvasHeight); 
   
                  // Get the DIV element from the HTML document by its ID and append the renderers DOM 
                  // object to it 
                  document.getElementById("WebGLCanvas").appendChild(renderer.domElement); 
   
                  // Create the scene, in which all objects are stored (e. g. camera, lights, 
                  // geometries, ...) 
                  scene = new THREE.Scene(); 
   
                  // Now that we have a scene, we want to look into it. Therefore we need a camera. 
                  // Three.js offers three camera types: 
                 //  - PerspectiveCamera (perspective projection) 
                  //  - OrthographicCamera (parallel projection) 
                  //  - CombinedCamera (allows to switch between perspective / parallel projection 
                  //    during runtime) 
                  // In this example we create a perspective camera. Parameters for the perspective 
                 // camera are ... 
                 // ... field of view (FOV), 
                 // ... aspect ratio (usually set to the quotient of canvas width to canvas height) 
                 // ... near and 
                 // ... far. 
                // Near and far define the cliping planes of the view frustum. Three.js provides an 
                 // example (http://mrdoob.github.com/three.js/examples/ 
                 // -> canvas_camera_orthographic2.html), which allows to play around with these 
                 // parameters. 
                 // The camera is moved 10 units towards the z axis to allow looking to the center of 
                 // the scene. 
                 // After definition, the camera has to be added to the scene. 
                 //camera = new THREE.PerspectiveCamera(45, canvasWidth / canvasHeight, 1, 100); 
                //camera.position.set(0, 0, 10); 
                //camera.lookAt(scene.position); 
                
				
				// taking cube example the new camera configuration is settled 
				camera = new THREE.PerspectiveCamera( 45, canvasWidth /canvasHeight, 1, 100 );
				camera.position.y = 0;
				camera.position.x = 0;
				camera.position.z = 5;
				
				scene.add(camera); 
  
                 // Create the triangle (or any arbitrary geometry). 
                 // 1. Instantiate the geometry object 
                 // 2. Add the vertices 
                 // 3. Define the faces by setting the vertices indices 
                 
  
               
               
  
                 // The creation of the square is done in the same way as the triangle, except of the 
                 // face definition. Instead of using one THREE.Face3, we have to define two 
                 // THREE.Face3 objects. 
                // 1. Instantiate the geometry object 
                 // 2. Add the vertices 
                 // 3. Define the faces by setting the vertices indices 
                 var squareGeometry = new THREE.Geometry(); 
                 squareGeometry.vertices.push(new THREE.Vector3(-1,  0.5, 0.0)); 
                 squareGeometry.vertices.push(new THREE.Vector3( 1, 0.5, 0.0)); 
                squareGeometry.vertices.push(new THREE.Vector3( 1, -0.5, 0.0)); 
                 squareGeometry.vertices.push(new THREE.Vector3(-1, -0.5, 0.0)); 
                 squareGeometry.faces.push(new THREE.Face3(0, 1, 2)); 
                 squareGeometry.faces.push(new THREE.Face3(0, 2, 3)); 
				 
				 
				 
				 var triangleGeo = new THREE.Geometry();
				triangleGeo.vertices.push(new THREE.Vector3(1.0, 1.0, 0.0));
				triangleGeo.vertices.push(new THREE.Vector3(0.0, -1.0, 0.0));
				triangleGeo.vertices.push(new THREE.Vector3(1.0, -1.0, 0.0));
				triangleGeo.faces.push(new THREE.Face3(0,1,2));
				
  
				// Light sensor Set up 
				var ligthSensoGeo = new THREE.Geometry();
				// 2d vertices square floor 
				ligthSensoGeo.vertices.push(new THREE.Vector3(0,0.125,1.5));  //0
				ligthSensoGeo.vertices.push(new THREE.Vector3(0.0625,0.0625,1.5)); //1
				ligthSensoGeo.vertices.push(new THREE.Vector3(0,0,1.5));//2
				ligthSensoGeo.vertices.push(new THREE.Vector3(0.125,0.125,1.5)); //3
				ligthSensoGeo.vertices.push(new THREE.Vector3(0.125,0,1.5));//4
				
				// adding more vertices to generate cube box
				ligthSensoGeo.vertices.push(new THREE.Vector3(0,.125,-1.5)); // 5
				ligthSensoGeo.vertices.push(new THREE.Vector3(0.125,0.125,-1.5)); //6
				//ligthSensoGeo.vertices.push(new THREE.Vector3(0.125,0,0)); //7
				//ligthSensoGeo.vertices.push(new THREE.Vector3(0,0,0));//8
				
				ligthSensoGeo.faces.push(new THREE.Face3(0,1,2));
				ligthSensoGeo.faces.push(new THREE.Face3(0,1,3));
				ligthSensoGeo.faces.push(new THREE.Face3(1,2,4));
				ligthSensoGeo.faces.push(new THREE.Face3(1,3,4));
				

				
				var skyBoxGeometry = new THREE.BoxGeometry( .5,.5, .5 );
				var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side:THREE.DoubleSide } );
				var boxMaterials = [ 
                    new THREE.MeshBasicMaterial({color:0xFF0000 , side:THREE.DoubleSide}), 
                     new THREE.MeshBasicMaterial({color:0x00FF00 ,  side:THREE.DoubleSide }), 
                     new THREE.MeshBasicMaterial({color:0x0000FF , side:THREE.DoubleSide}), 
                     new THREE.MeshBasicMaterial({color:0xFFFF00 , side:THREE.DoubleSide}), 
                    new THREE.MeshBasicMaterial({color:0x00FFFF , side:THREE.DoubleSide}), 
                     new THREE.MeshBasicMaterial({color:0xFFFFFF , side:THREE.DoubleSide}) 
                 ]; 
				
				 skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
				 skyBox.position.set(-3, 0.0 ,1.0);
				scene.add(skyBox); 
				
				// adding new triangle faces which are needed for the cube box sensor
				//ligthSensoGeo.faces.push(new THREE.Face3(0,3,5));
				/**ligthSensoGeo.faces.push(new THREE.Face3(3,5,6));
				ligthSensoGeo.faces.push(new THREE.Face3(2,4,7));
				ligthSensoGeo.faces.push(new THREE.Face3(2,7,8));
				
				ligthSensoGeo.faces.push(new THREE.Face3(3,4,7));
				ligthSensoGeo.faces.push(new THREE.Face3(3,6,7));
				
				
				ligthSensoGeo.faces.push(new THREE.Face3(0,2,8));
				ligthSensoGeo.faces.push(new THREE.Face3(0,5,8));
				
				
				
				ligthSensoGeo.faces.push(new THREE.Face3(5,6,7));
				ligthSensoGeo.faces.push(new THREE.Face3(5,7,8));
				*/
				
                 // The square gets a new face color. In contrast to vertex colors means face color, 
                // that all vertices have the same color or in other words, the whole face has the 
                 // same color (no color gradients). 
				
				
				//var neheTexture = new THREE.ImageUtils.loadTexture("playground.jpg");
                 // Create a light blue basic material and activate the 'doubleSided' attribute. 
                 //var squareMaterial = new THREE.MeshBasicMaterial( { map: texture }) ; third try
				 
				  var squareMaterial= new THREE.MeshBasicMaterial({ 
                     color:0x8080FF, 
					// map:neheTexture, 
                     side:THREE.DoubleSide 
                 }); 
  
				
				var triMaterial = new THREE.MeshBasicMaterial({
					 color:0xAAAAFF, 
					// map:neheTexture, 
                     side:THREE.DoubleSide 
				
				});		
				
				var ligthSensoMat = new THREE.MeshBasicMaterial({
					 color:0xFF0000, 
					// map:neheTexture, 
                     side:THREE.DoubleSide 
				
				});

				
                 // Create a mesh and insert the geometry and the material. Translate the whole mesh 
                // by 1.5 on the x axis and by 4 on the z axis and add the mesh to the scene. 
                squareMesh = new THREE.Mesh(squareGeometry, squareMaterial); 
                squareMesh.position.set(1, 0.0, 4.0); 
                scene.add(squareMesh); 
				
				triMesh = new THREE.Mesh(triangleGeo, triMaterial); 
                triMesh.position.set(1, 0.0 ,-1.0); 
                scene.add(triMesh); 
				
				lightSensoMesh = new THREE.Mesh(ligthSensoGeo,ligthSensoMat) ;
				lightSensoMesh.position.set(-2.0, 0.0, 1.0) ;
				scene.add(lightSensoMesh);
				
            } 
  
             /** 
              * Animate the scene and call rendering. 
              */ 
             function animateScene(){ 
                // At first, we increase the y rotation of the triangle mesh and decrease the x 
                 // rotation of the square mesh. 
              
                 // Increase the y rotation of the triangle 
                // triangleMesh.rotation.y += 0.1; 
  
                 // Decrease the x rotation of the square 
				 myMotion = getRotationWheel( squareMesh.position.x);// patch it
				 if(myMotion == 0) {
				 squareMesh.position.x = 1 ;
				  resetMeterCounter();
				 }
                 squareMesh.position.x += 0.00075*myMotion; 
				 
				 skyBox.rotateOnAxis(new THREE.Vector3(1, 1, 1).normalize(), 0.075); 
				 
                 // Define the function, which is called by the browser supported timer loop. If the 
                 // browser tab is not visible, the animation is paused. So 'animateScene()' is called 
                 // in a browser controlled loop. 
                 requestAnimationFrame(animateScene); 
  
                 // Map the 3D scene down to the 2D screen (render the frame) 
                 renderScene(); 
             } 
  
             /** 
              * Render the scene. Map the 3D world to the 2D screen.
              */ 
             function renderScene(){ 
                 renderer.render(scene, camera); 
             } 
         </script> 
    </body> 
 </html>