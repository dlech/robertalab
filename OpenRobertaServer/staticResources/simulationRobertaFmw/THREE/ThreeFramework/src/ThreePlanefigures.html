 <!DOCTYPE html> 
   <!-- The previous line tells the browser, that the page uses the HTML5 standard. --> 
    
<html>
	<head> 
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
		<! helps to keep size>
		<meta name= "viewport" content = "width =device-width ,  height= device-height, initial-scale = 1"> 
		<style type="text/css"> 
			body{
				background-color: #00FFFF ;
				overflow : hidden;
			}
		</style>
		<! include the libraries,   Projector>
		<script src = "http://threejs.org/build/three.min.js"></script>
		<script src = "Detector.js"></script> <! one can ask this condition on the site face as well.>
		<script src = "GeneratorRoberta.js"></script>
		<!script src = "CanvasRenderer.js"></script>
		<!script src = "WebGLRenderer.js"></script>
		<!script src = "Projector.js"></script>
		<!script src = "Color.js"></script>
		<!script src = "Frustum.js"></script>
		<!script src = "Sphere.js"></script>
	</head>
	<body>
		<div id = "WebGlCANVAS"> </div>
		<script>
   
			var scene ;
			var camera ;
			var triangleMesh ;
			var squareMesh ;
			// initialize scene
			initializeScene();
			
			// then render scene 
			renderScene();
			
			
			
			// initializeScene function
			function initializeScene(){
				
				//find which kind of canvas is supported
				if(Detector.webgl){
					renderer = new THREE.WebGLRenderer({antialias:true});
					
				}else{
					renderer = new THREE.CanvasRenderer();
					
				}
				
				// setting background color
				renderer.setClearColor(0x000000, 1) ;
				
				canvasWidht = window.innerWidth ;
				canvasHeight=  window.innerHeight;
				
				
				renderer.setSize(canvasWidht, canvasHeight);
				
				document.getElementById("WebGlCANVAS").appendChild(renderer.domElement);
				
				
				
				// now create a scene
				scene = new THREE.Scene();
				
				
				// then camera settings taking exammple http://www.johannes-raida.de/tutorials/three.js/tutorial02/tutorial02.htm
				// seems that we use orthographic projection
				camera = new THREE.PerspectiveCamera(45, canvasWidht / canvasHeight, 1, 100); 
				camera.position.set(0, 0, 10); 
                camera.lookAt(scene.position); 
                
				scene.add(camera);
				
				
				
				// then make the figures in this case triangle
				var triangleGeometry = new THREE.Geometry(); 
                triangleGeometry.vertices.push(new THREE.Vector3( 0.0,  1.0, 0.0)); 
                triangleGeometry.vertices.push(new THREE.Vector3(-1.0, -1.0, 0.0)); 
                triangleGeometry.vertices.push(new THREE.Vector3( 1.0, -1.0, 0.0)); 
                triangleGeometry.faces.push(new THREE.Face3(0, 1, 2));
				
				
				var squareGeometry = new THREE.Geometry();
				squareGeometry.vertices.push(new THREE.Vector3(-1.0,1.0, 0.0));
				squareGeometry.vertices.push(new THREE.Vector3(1.0,1.0, 0.0));
				squareGeometry.vertices.push(new THREE.Vector3(1.0,-1.0, 0.0));
				squareGeometry.vertices.push(new THREE.Vector3(-1.0,-1.0, 0.0));
				
				//faces
				squareGeometry.faces.push(new THREE.Face3(0,1,2)) ;
				squareGeometry.faces.push(new THREE.Face3(0,2,3)) ;
				
				// add material	
				var triangleMaterial = new THREE.MeshBasicMaterial({
					color	: 	0xFFFFFF,
					side	:	THREE.doubleSide
				
				
				});
				
				var squareMaterial = new THREE.MeshBasicMaterial({
					color:0x8080FF,
					side : THREE.doubleSide 
				
				
				});
			
			
				triangleMesh = new THREE.Mesh(triangleGeometry,triangleMaterial);
				// then move to specific position 
				triangleMesh.position.set(-1.5, 0.0, 4.0);
				
				
				
				
				squareMesh = new THREE.Mesh(squareGeometry, squareMaterial);
				squareMesh.position.set(1.5, 0.0, 4.0);
				
				// later add the mesh on the scene
				scene.add(triangleMesh);
				scene.add(squareMesh);
				
			
			
			}
				
			function  renderScene(){
				requestAnimationFrame(renderScene) ;
				triangleMesh.rotation.z += 0.1 ;
				//squareMesh.position.x += 0.1 ;
				renderer.render(scene, camera) ;
			}
		
		
		</script>
		
		
	</body> 
 </html>