<!DOCTYPE html> 
   <!-- The previous line tells the browser, that the page uses the HTML5 standard. --> 
    
   <html>
       <head>
           <title>Roberta SImuli  Prototype Three.js</title> 
           <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"> 
    
           <!-- The following meta line optimizes the site for mobile devices. It sets the viewport size 
          to the screen size, so it will be displayed maximized, but unscaled. --> 
          <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"> 
          <style type="text/css"> 
              body { 
                  /* Set the background color of the HTML page to black */ 
                  background-color: #000000; 
   
                  /* Hide oversized content. This prevents the scroll bars. */ 
                  overflow: hidden; 
              } 
          </style> 
          <!-- Include Three.js libraries --> 
		  <!script src = "http://threejs.org/build/three.min.js"></script>
		<!script src = "Detector.js"></script> <! one can ask this condition on the site face as well.>
		<script src = "GeneratorRoberta.js"></script>
		<script src = "meshHanlder.js"></script>
		<script src="../build/three.min.js"></script>

		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>

		<script src="js/libs/stats.min.js"></script>
  
      </head> 
      <body>
          <!-- This is the DIV element which will contain the WebGL canvas. To be identifiable lateron, 
          the id 'WebGLCanvas' is applied to it. --> 
          <div id="WebGLCanvas"> 
   
          <!-- This JavaScript block encloses the Three.js commands --> 
          <script> 
            // code for adding a new canvas
			/**	var canvas = document.createElement("canvas");
				var context = canvas.getContext("2d");
			  
			   var image0 = new Image();
				var texture = new THREE.Texture(canvas);
				
				
				
				image0.onload = function() {
				context.drawImage(image0, 0, 0);
				texture.needsUpdate = true;
				};
				image0.src = 'playground.jpg';
			  */
			  
			  // Global scene object 
              var scene; 
   
              // Global camera object  
              var camera; 
   
              
			  // variables belonging raycasting 
			  var collidableMeshList = [];
			  var colorReadableMeshList = [] ;
			  
			  
			  // variables needed for communication with Roberta Server
			  var inpoutValuesRobot = [];
			  
			  
              // Global mesh object of the square 
              var squareMesh; 
			  var triMesh ;
			  var lightSensoMesh;
			  var skyBox ;
			  var bumperMesh ;
			  var obstacleShepereMesh ;
			  var octoedroMesh;
   
			  var myMotion ;
			  var distance ;
              // Initialize the scene 
              initializeScene(); 
   
              // Instead of calling 'renderScene()', we call a new function: 'animateScene()'. It will 
              // update the rotation values and call 'renderScene()' in a loop. 
   
              // Animate the scene 
              animateScene(); 
   
              /** 
               * Initialze the scene. 
               */ 
              function initializeScene(){ 
                
                 // if(Detector.webgl){ 
                   //   renderer = new THREE.WebGLRenderer({antialias:true}); 
   
                  // If its not supported, instantiate the canvas renderer to support all non WebGL 
                  // browsers 
                  //} else { 
                      renderer = new THREE.CanvasRenderer(); // WE agreed of keep as DEFAULT Canvas 
                  //} 
   
                  // Set the background color of the renderer to black, with full opacity 
                  renderer.setClearColor(0x000000, 1); 
  
                  // Get the size of the inner window (content area) to create a full size renderer 
                  canvasWidth = window.innerWidth; 
                  canvasHeight = window.innerHeight; 
   
                // Set the renderers size to the content areas size 
                  renderer.setSize(canvasWidth, canvasHeight); 
   
                  // Get the DIV element from the HTML document by its ID and append the renderers DOM 
                  // object to it 
                  document.getElementById("WebGLCanvas").appendChild(renderer.domElement); 
   
                  // Create the scene, in which all objects are stored (e. g. camera, lights, 
                  // geometries, ...) 
                  scene = new THREE.Scene(); 
   
                
                
				
				// taking cube example the new camera configuration is settled 
				camera = new THREE.PerspectiveCamera( 50,  window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.y = 0;
				camera.position.x = 0;
				camera.position.z = 14;
				scene.add(camera); 
  
              
                 var squareGeometry = new THREE.Geometry(); 
                 squareGeometry.vertices.push(new THREE.Vector3(-.5,  0.5, 0.0)); 
                 squareGeometry.vertices.push(new THREE.Vector3( .5, 0.5, 0.0)); 
                squareGeometry.vertices.push(new THREE.Vector3( .5, -0.5, 0.0)); 
                 squareGeometry.vertices.push(new THREE.Vector3(-.5, -0.5, 0.0)); 
                 squareGeometry.faces.push(new THREE.Face3(0, 1, 2)); 
                 squareGeometry.faces.push(new THREE.Face3(0, 2, 3)); 
				 
				 
				 
				
				
  
				// Light sensor Set up 
				var ligthSensoGeo = new THREE.Geometry();
				// 2d vertices square floor 
				ligthSensoGeo.vertices.push(new THREE.Vector3(-.0625,.0625,-.0625));  //0
				ligthSensoGeo.vertices.push(new THREE.Vector3(0,0,-.0625)); //1
				ligthSensoGeo.vertices.push(new THREE.Vector3(-.0625,-.0625,-.0625));//2
				ligthSensoGeo.vertices.push(new THREE.Vector3(0.0625,0.0625,-0.0625)); //3
				ligthSensoGeo.vertices.push(new THREE.Vector3(0.0625,-0.0625,-0.0625));//4
				
				// adding more vertices to generate cube box
				ligthSensoGeo.vertices.push(new THREE.Vector3(-.0625,.0625,0.0625));  //5
				ligthSensoGeo.vertices.push(new THREE.Vector3(0.0625,0.0625,0.0625));//6
				ligthSensoGeo.vertices.push(new THREE.Vector3(0.0625,-0.0625,0.0625));//7
				ligthSensoGeo.vertices.push(new THREE.Vector3(-0.0625,-0.0625,0.0625)); //8
				
				
				ligthSensoGeo.faces.push(new THREE.Face3(0,1,2));
				ligthSensoGeo.faces.push(new THREE.Face3(0,1,3));
				ligthSensoGeo.faces.push(new THREE.Face3(1,2,4));
				ligthSensoGeo.faces.push(new THREE.Face3(1,3,4));
				
				
				// adding new triangle faces which are needed for the cube box sensor
				ligthSensoGeo.faces.push(new THREE.Face3(0,3,5));
				ligthSensoGeo.faces.push(new THREE.Face3(3,5,6));
				ligthSensoGeo.faces.push(new THREE.Face3(2,4,7));
				ligthSensoGeo.faces.push(new THREE.Face3(2,7,8));
				
				ligthSensoGeo.faces.push(new THREE.Face3(3,4,7));
				ligthSensoGeo.faces.push(new THREE.Face3(3,6,7));
				
				
				ligthSensoGeo.faces.push(new THREE.Face3(0,2,8));
				ligthSensoGeo.faces.push(new THREE.Face3(0,5,8));
				
				
				
				ligthSensoGeo.faces.push(new THREE.Face3(5,6,7));
				ligthSensoGeo.faces.push(new THREE.Face3(5,7,8));
				
				
				
				
				var bumperGeometry = new THREE.Geometry();
				bumperGeometry.vertices.push(new THREE.Vector3(-.375,.625,-.2));  //0
				bumperGeometry.vertices.push(new THREE.Vector3(-.125,.625,-.2));  //1
				bumperGeometry.vertices.push(new THREE.Vector3(-.125,.5,-.2));  //2
				bumperGeometry.vertices.push(new THREE.Vector3(.125,.5,-.2));  //3
				bumperGeometry.vertices.push(new THREE.Vector3(-.125,-.5,-.2));  //4
				bumperGeometry.vertices.push(new THREE.Vector3(.125,-.5,-.2));  //5
				bumperGeometry.vertices.push(new THREE.Vector3(-.375,-.625,-.2));  //6
				bumperGeometry.vertices.push(new THREE.Vector3(-.125,-.625,-.2));  //7
				
				
				
				// top vertices of bumper 
				bumperGeometry.vertices.push(new THREE.Vector3(-.375,.625,.2));  //8
				bumperGeometry.vertices.push(new THREE.Vector3(-.125,.625,.2));  //9
				bumperGeometry.vertices.push(new THREE.Vector3(-.125,.5,.2));  //10
				bumperGeometry.vertices.push(new THREE.Vector3(.125,.5,.2));  //11
				bumperGeometry.vertices.push(new THREE.Vector3(-.125,-.5,.2));  //12
				bumperGeometry.vertices.push(new THREE.Vector3(.125,-.5,.2));  //13
				bumperGeometry.vertices.push(new THREE.Vector3(-.375,-.625,.2));  //14
				bumperGeometry.vertices.push(new THREE.Vector3(-.125,-.625,.2));  //15
				
				bumperGeometry.vertices.push(new THREE.Vector3(.125,0,0));  //16 centre of the front bumper
				bumperGeometry.vertices.push(new THREE.Vector3(.125,.25,0));  //17 
				bumperGeometry.vertices.push(new THREE.Vector3(.125,-.25,0));  //18 
				
				
				// triangles faces of bumper 
					// floor 
				bumperGeometry.faces.push(new THREE.Face3(0,1,2));  
				bumperGeometry.faces.push(new THREE.Face3(1,2,3));
				bumperGeometry.faces.push(new THREE.Face3(2,3,4));
				bumperGeometry.faces.push(new THREE.Face3(3,4,5));  
				bumperGeometry.faces.push(new THREE.Face3(4,5,7));
				bumperGeometry.faces.push(new THREE.Face3(4,6,7));
				
					//top
				bumperGeometry.faces.push(new THREE.Face3(8,9,10));  
				bumperGeometry.faces.push(new THREE.Face3(9,10,11));
				bumperGeometry.faces.push(new THREE.Face3(10,11,12));
				bumperGeometry.faces.push(new THREE.Face3(11,12,13));  
				bumperGeometry.faces.push(new THREE.Face3(12,13,15));
				bumperGeometry.faces.push(new THREE.Face3(12,14,15));
				
				
					//front
				bumperGeometry.faces.push(new THREE.Face3(5,13,18));  
				bumperGeometry.faces.push(new THREE.Face3(3,11,17));
				bumperGeometry.faces.push(new THREE.Face3(13,16,18));
				bumperGeometry.faces.push(new THREE.Face3(11,13,16)); 
				bumperGeometry.faces.push(new THREE.Face3(11,16,17)); 		
				bumperGeometry.faces.push(new THREE.Face3(5,16,18));
				bumperGeometry.faces.push(new THREE.Face3(3,16,17));
				bumperGeometry.faces.push(new THREE.Face3(3,5,16));
				
				
					//back faces
				bumperGeometry.faces.push(new THREE.Face3(0,8,10));  
				bumperGeometry.faces.push(new THREE.Face3(0,2,10));
				bumperGeometry.faces.push(new THREE.Face3(2,4,10));
				bumperGeometry.faces.push(new THREE.Face3(4,10,12)); 
				bumperGeometry.faces.push(new THREE.Face3(4,12,14)); 
				bumperGeometry.faces.push(new THREE.Face3(4,6,14)); 
				
				
				
							// sides
				bumperGeometry.faces.push(new THREE.Face3(0,1,8));  
				bumperGeometry.faces.push(new THREE.Face3(1,3,11));
				bumperGeometry.faces.push(new THREE.Face3(1,8,9));
				bumperGeometry.faces.push(new THREE.Face3(1,9,11));
				
				bumperGeometry.faces.push(new THREE.Face3(5,7,13)); 
				bumperGeometry.faces.push(new THREE.Face3(7,13,15)); 
				bumperGeometry.faces.push(new THREE.Face3(7,14,15)); 
				bumperGeometry.faces.push(new THREE.Face3(7,6,14)); 
				
				
				
				var skyBoxGeometry = new THREE.BoxGeometry( 1,2, 1 );
				var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x00FF00, side:THREE.DoubleSide } );
				
				
				var longboxGeometry = new THREE.BoxGeometry( 1,1, 1 );
				var longBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xF7D117, side:THREE.DoubleSide } );
				/*
				var boxMaterials = [ 
                    new THREE.MeshBasicMaterial({color:0xFF0000 , side:THREE.DoubleSide}), 
                     new THREE.MeshBasicMaterial({color:0x00FF00 ,  side:THREE.DoubleSide }), 
                     new THREE.MeshBasicMaterial({color:0x0000FF , side:THREE.DoubleSide}), 
                     new THREE.MeshBasicMaterial({color:0xFFFF00 , side:THREE.DoubleSide}), 
                    new THREE.MeshBasicMaterial({color:0x00FFFF , side:THREE.DoubleSide}), 
                     new THREE.MeshBasicMaterial({color:0xFFFFFF , side:THREE.DoubleSide}) 
                 ]; 
				*/ // seems no supported
				var playgroundGeometry = new THREE.Geometry(); 
                playgroundGeometry.vertices.push(new THREE.Vector3(-6,  6, 0.0)); 
                playgroundGeometry.vertices.push(new THREE.Vector3( 6, 6, 0.0)); 
                playgroundGeometry.vertices.push(new THREE.Vector3( 6, -6, 0.0)); 
                playgroundGeometry.vertices.push(new THREE.Vector3(-6, -6, 0.0)); 
                playgroundGeometry.faces.push(new THREE.Face3(0, 1, 2)); 
                playgroundGeometry.faces.push(new THREE.Face3(0, 2, 3));
				
				
				var obstacleSphereGeo = new THREE.SphereGeometry(1,10,10) ;
				var sphereMaterial= new THREE.MeshBasicMaterial({ 
                     color:0x00642E,  
                     side:THREE.DoubleSide 
                 }); 
				
				
				
				
				group = new THREE.Object3D();
				
				
                 
				var squareMaterial= new THREE.MeshBasicMaterial({ 
                     color:0x8080FF, 
					// map:neheTexture, 
                     side:THREE.DoubleSide 
                 }); 
  
				
				var triMaterial = new THREE.MeshBasicMaterial({
					 color:0xAAAAFF, 
					
                     side:THREE.DoubleSide 
				
				});		
				
				var ligthSensoMat = new THREE.MeshBasicMaterial({
					 color:0xFF0000, 
					
                     side:THREE.DoubleSide 
				
				});

				
				var bumperMat = new THREE.MeshBasicMaterial({
					 //color:0xF7D117, yellow
						color:0xFFFFFF, 
					
                     side:THREE.DoubleSide 
				
				});
				
				var playMaterial = new THREE.MeshBasicMaterial({
					 color:0xcdc9c9, 
					
                     side:THREE.DoubleSide 
				
				});		
				
				
				
				var curve = new THREE.CubicBezierCurve3( new THREE.Vector3( -5.5, 0, 0 ), 
					new THREE.Vector3( -2, -3, 0 ), new THREE.Vector3( 6, 9, 0 ),
						new THREE.Vector3( 5, -5.79, 0 ) );
				var geometry = new THREE.Geometry(); geometry.vertices = curve.getPoints( 50 ); 
				var material = new THREE.LineBasicMaterial( { color : 0x000000,  linewidth: 9} ); 
				var curveObject = new THREE.Line( geometry, material );
                
				curveObject.position.set(-.4,0,.001)
				
                squareMesh = new THREE.Mesh(squareGeometry, squareMaterial); 
                squareMesh.position.set(0, 0.0, 0.0); 
                
				
				
				
				lightSensoMesh = new THREE.Mesh(ligthSensoGeo,ligthSensoMat) ;
				//lightSensoMesh.position.set(.5625,0,-0.0625) ; optimal one 20 april 2015 , 17 hrs
				lightSensoMesh.position.set(0,0,-0.0625) ;
				
				
				
				
				skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
				skyBox.position.set(0, -.5 ,-.5);
				
				
				bumperMesh = new THREE.Mesh(bumperGeometry,bumperMat) ;
				bumperMesh.position.set(.625,0,-.2) ;
				
				
				
				playgroundMesh = new THREE.Mesh(playgroundGeometry, playMaterial); 
                playgroundMesh.position.set(0, 0.0, -1.5); 
				
				obstacleShepereMesh = new THREE.Mesh(obstacleSphereGeo, sphereMaterial) ;
				obstacleShepereMesh.position.set(3,4,0)
				
				
				octoedroMesh = new THREE.Mesh(longboxGeometry, longBoxMaterial);
				octoedroMesh.position.set(-4,-3,0);
				
				
				group.position.set(-3,+1,-.5);
				
				var cloneCube = octoedroMesh.clone();
				cloneCube.position.set(2,-1.5,1);
				
				playgroundMesh.add(curveObject);
				playgroundMesh.add(obstacleShepereMesh);
				playgroundMesh.add(octoedroMesh);
				playgroundMesh.add(cloneCube);
				
				scene.add(playgroundMesh);
				
				scene.add(skyBox);
				
				group.add(lightSensoMesh);
				group.add(squareMesh) ;
				group.add(bumperMesh) ;
				
				
				// first the group should be added on the scene
				scene.add(group) ;
				
				
				
				// raycasting settings
					// collidable list objects 	
					collidableMeshList.push(obstacleShepereMesh);
					collidableMeshList.push(skyBox);
					collidableMeshList.push(cloneCube);
					collidableMeshList.push(octoedroMesh);
					
					colorReadableMeshList.push(curveObject);
				
            } 
  
             /** 
              * Animate the scene and call rendering. 
              */ 
             function animateScene(){ 
              
				 
				var positionW = new THREE.Vector3();
					positionW.setFromMatrixPosition( lightSensoMesh.matrixWorld );	
				// raytracing section
				for(floorVertexIndex = 0; floorVertexIndex< 4;floorVertexIndex++){
					var localVertex = lightSensoMesh.geometry.vertices[floorVertexIndex].clone();
					var globalVertex = localVertex.applyMatrix4( lightSensoMesh.matrix );
					var directionVector = globalVertex.sub( lightSensoMesh.position );
					var ray = new THREE.Raycaster( positionW, directionVector.clone() ,0, .3);// just one unit magnitude
					var collisionResults = ray.intersectObjects( colorReadableMeshList );
					
					
					if ( collisionResults.length > 0  )
						{
							// HERE THE READING OF LIGHT SENSOR HAPPENS 
							inpoutValuesRobot[LIGHT_COLOR_FLAG_INDEX] = true ;
							inpoutValuesRobot[LIGHT_COLOR_INDEX]  = "" + decimal2Hex(collisionResults[0].object.material.color.r,2) 
								+ decimal2Hex(collisionResults[0].object.material.color.g,2) 
								+ decimal2Hex(collisionResults[0].object.material.color.b,2) ;
							//collisionResults[0].object.material.color.setRGB(Math.random(),Math.random(),Math.random() );
						 
						}
				}
				
				
				 var positionBump = new THREE.Vector3();
					positionBump.setFromMatrixPosition( bumperMesh.matrixWorld );
				for(VertexIndex = 0; VertexIndex< bumperMesh.geometry.vertices.length;VertexIndex++){
					var localVertexB = bumperMesh.geometry.vertices[VertexIndex].clone();
					var globalVertexB = localVertexB.applyMatrix4( bumperMesh.matrix );
					var directionVectorB = globalVertexB.sub( bumperMesh.position );
					var rayB = new THREE.Raycaster( positionBump, directionVectorB.clone().normalize() );// just one unit magnitude
					var collisionResultsB = rayB.intersectObjects( collidableMeshList );
					if ( collisionResultsB.length > 0 && collisionResultsB[0].distance < directionVectorB.length() )
						{
							// HERE THE COLLISION HAPPENS AND TODO PLACE
							//var oldColor = collisionResults[0].object.material.color ;
							collisionResultsB[0].object.material.color.setRGB(Math.random(),Math.random(),Math.random() ); 
							//above changes randomize the color of touched object
						 
						}
				}
					
				gatherInputData();	
				transformBrick(setInputValuesRoboterta(inpoutValuesRobot)) ; // calling Open Roberta Generator.
				
                requestAnimationFrame(animateScene); 
  
                 // Map the 3D scene down to the 2D screen (render the frame) 
                 renderScene(); 
             } 
  
             /** 
              * Render the scene. Map the 3D world to the 2D screen.
              */ 
             function renderScene(){ 
                 renderer.render(scene, camera); 
             } 
			 
			 
			 function transformBrick(valuesBrick){
			 
				//inpoutValuesRobot = valuesBrick;
				group.position.x += valuesBrick[POSITION_X_INDEX] ;
				//group.position.y += valuesBrick[POSITION_Y_INDEX] ;
				if(valuesBrick[ROTATION_Z_INDEX]>0){
				
					group.rotation.z += valuesBrick[ROTATION_Z_INDEX] ;
				}else{
					group.rotation.z = 0;
				
				}
				
				inpoutValuesRobot[LIGHT_COLOR_FLAG_INDEX] = valuesBrick[LIGHT_COLOR_FLAG_INDEX];
				inpoutValuesRobot[LIGHT_COLOR_INDEX] = valuesBrick[LIGHT_COLOR_INDEX];
			 
			 }
			 
			 function gatherInputData(){
				inpoutValuesRobot[POSITION_X_INDEX] = group.position.x ;
				inpoutValuesRobot[POSITION_Y_INDEX] = group.position.y ;
				inpoutValuesRobot[COLLISION_FLAG_INDEX] = true ;
				
				inpoutValuesRobot[ROTATION_Z_INDEX] = group.rotation.z ;
				
				
				
			 }
			 
			 
			 
			 function decimal2Hex(d, padding) 
			 {
				var hex = Number(d).toString(16);
				padding = typeof (padding) === "undefined" || padding === null ? padding = 2 : padding;

				while (hex.length < padding) {
					hex = "0" + hex;
				}

				return hex;
			}
			
			
			
			function decimalToHex(d) {
					var hex = Number(d).toString(16);
				hex = "000000".substr(0, 6 - hex.length) + hex; 
				return hex;
			}
         </script> 
    </body> 
 </html>