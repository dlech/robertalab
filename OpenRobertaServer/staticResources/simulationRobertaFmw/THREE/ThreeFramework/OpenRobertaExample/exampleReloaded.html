<!DOCTYPE html> 
   <!-- The previous line tells the browser, that the page uses the HTML5 standard. --> 
    
   <html>
       <head>
           <title>Roberta SImuli  Prototype Three.js</title> 
           <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"> 
    
           <!-- The following meta line optimizes the site for mobile devices. It sets the viewport size 
          to the screen size, so it will be displayed maximized, but unscaled. --> 
          <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"> 
          <style type="text/css"> 
              body { 
                  /* Set the background color of the HTML page to black */ 
                  background-color: #000000; 
   
                  /* Hide oversized content. This prevents the scroll bars. */ 
                  overflow: hidden; 
              } 
          </style> 
          <!-- Include Three.js libraries --> 
		  <!script src = "http://threejs.org/build/three.min.js"></script>
		<!script src = "Detector.js"></script> <! one can ask this condition on the site face as well.>
		<script src = "GeneratorRoberta.js"></script>
		<!script src = "meshHandler.js"></script>
		<script src = "meshHandlerPostiveCoordinates.js"></script>
		<script src = "robotMotionHandler.js"></script>
		<script src="../build/three.min.js"></script>

		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>

		<script src="js/libs/stats.min.js"></script>
  
      </head> 
      <body>
          <!-- This is the DIV element which will contain the WebGL canvas. To be identifiable lateron, 
          the id 'WebGLCanvas' is applied to it. --> 
          <output id="out"></output>
		  <div id="WebGLCanvas"> 
   
          <!-- This JavaScript block encloses the Three.js commands --> 
          <script> 
            // code for adding a new canvas
			/**	var canvas = document.createElement("canvas");
				var context = canvas.getContext("2d");
			  
			   var image0 = new Image();
				var texture = new THREE.Texture(canvas);
				
				
				
				image0.onload = function() {
				context.drawImage(image0, 0, 0);
				texture.needsUpdate = true;
				};
				image0.src = 'playground.jpg';
			  */
			  
			  // variables for stats
			  var startTime	= Date.now();
			  var stats ;
			  
			  // Global scene object 
              var scene; 
   
              // Global camera object  
              var camera; 
   
              
			  // variables belonging raycasting 
			  var collidableMeshList = [];
			  var colorReadableMeshList = [] ;
			  
			  
			  // variables needed for communication with Roberta Server
			  var inpoutValuesRobot = [];
			  
			  
              
   
			  var myMotion ;
			  var distance ;
			  
			  
			  // Adding Clock object in order to control the fps speed
			  var  clock  ;
			  var  time   ;
			  var  delta  ;
			  
              // Initialize the scene 
              initializeScene(); 
   
              // Instead of calling 'renderScene()', we call a new function: 'animateScene()'. It will 
              // update the rotation values and call 'renderScene()' in a loop. 
			  
			  
			  
			  
   
              // Animate the scene 
              animateScene(); // adding new Timer  NewDate on 26Mai
   
              /** 
               * Initialze the scene. 
               */ 
              function initializeScene(){ 
                
                 // if(Detector.webgl){ 
                   //   renderer = new THREE.WebGLRenderer({antialias:true}); 
   
                  // If its not supported, instantiate the canvas renderer to support all non WebGL 
                  // browsers 
                  //} else { 
                      renderer = new THREE.CanvasRenderer(); // WE agreed of keep as DEFAULT Canvas  for Open Roberta easy access  
                  //} 
   
                  // Set the background color of the renderer to black, with full opacity 
                  renderer.setClearColor(0x000000, 1); 
  
                  // Get the size of the inner window (content area) to create a full size renderer 
                  canvasWidth = window.innerWidth; 
                  canvasHeight = window.innerHeight; 
   
                // Set the renderers size to the content areas size 
                  renderer.setSize(canvasWidth, canvasHeight); 
   
                  // Get the DIV element from the HTML document by its ID and append the renderers DOM 
                  // object to it 
                  document.getElementById("WebGLCanvas").appendChild(renderer.domElement); 
   
                  // Create the scene, in which all objects are stored (e. g. camera, lights, 
                  // geometries, ...) 
                  scene = new THREE.Scene(); 
   
                
                
				
				// taking cube example the new camera configuration is settled 
				camera = new THREE.PerspectiveCamera( 30,  window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.y = 6;
				camera.position.x = 6;
				camera.position.z = 30;  // for testing reasons the camera is change to  50 instead 30 
				//camera.rotation.y = .90 ;
				scene.add(camera); 
  
              
				
				instanceMeshes(); // calling for meshHandler a method which instances the meshes with their materials and properties.
				group.position.set(0,6,0); // change from -3, 1, -.5 to 0,6,0 to keep positive values 
				
				var cloneCube = octoedroMesh.clone();
				cloneCube.position.set(3,5.5,.5);// change from 2, -1.5, 1 to 8,5.5,.5to keep positive values
				
				playgroundMesh.add(curveObject);
				playgroundMesh.add(obstacleShepereMesh);
				playgroundMesh.add(octoedroMesh);
				//playgroundMesh.add(cloneCube); This time it is not required 
 				
				scene.add(playgroundMesh);
				
				scene.add(skyBox);
				
				group.add(lightSensoMesh);
				group.add(squareMesh) ;
				group.add(bumperMesh) ;
				
				
				// first the group should be added on the scene
				scene.add(group) ;
				
				
				
				// raycasting settings
					// collidable list objects 	
					collidableMeshList.push(obstacleShepereMesh);
					collidableMeshList.push(skyBox);
					//collidableMeshList.push(cloneCube); This example does not need this figure 
					collidableMeshList.push(octoedroMesh);
					
					colorReadableMeshList.push(curveObject);
					
					
				// fps counter stats variables
					// create the Stats element and append it to the Dome
					stats = new Stats();
					stats.domElement.style.position = 'absolute';
					stats.domElement.style.top = '0px';
					document.getElementById("WebGLCanvas").appendChild( stats.domElement ); 
					
				// making new instance of Clock object	
				clock = new THREE.Clock(); 
            } 
  
             /** 
              * Animate the scene and call rendering. 
              */ 
             function animateScene(){  // adding time t 26mai 
				
				//time = clock.getElapsedTime(); just for debugging 
				//delta = clock.getDelta() ;
				//console.log( "time" + time) ;
				renderScene(); 		
				
				var positionW = new THREE.Vector3();
					positionW.setFromMatrixPosition( lightSensoMesh.matrixWorld );	
				// raytracing section
				for(floorVertexIndex = 0; floorVertexIndex< 4;floorVertexIndex++){
					var localVertex = lightSensoMesh.geometry.vertices[floorVertexIndex].clone();
					var globalVertex = localVertex.applyMatrix4( lightSensoMesh.matrix );
					var directionVector = globalVertex.sub( lightSensoMesh.position );
					var ray = new THREE.Raycaster( positionW, directionVector.clone() ,0, .3);// just one unit magnitude
					var collisionResults = ray.intersectObjects( colorReadableMeshList );
					
					
					if ( collisionResults.length > 0  )
						{
							// HERE THE READING OF LIGHT SENSOR HAPPENS 
							inpoutValuesRobot[LIGHT_COLOR_FLAG_INDEX] = true ;
							inpoutValuesRobot[LIGHT_COLOR_INDEX]  = "" + decimal2Hex(collisionResults[0].object.material.color.r,2) 
								+ decimal2Hex(collisionResults[0].object.material.color.g,2) 
								+ decimal2Hex(collisionResults[0].object.material.color.b,2) ;
							//collisionResults[0].object.material.color.setRGB(Math.random(),Math.random(),Math.random() );
						 
						}
				}
				
				
				 var positionBump = new THREE.Vector3();
					positionBump.setFromMatrixPosition( bumperMesh.matrixWorld );
				for(VertexIndex = 0; VertexIndex< bumperMesh.geometry.vertices.length;VertexIndex++){
					var localVertexB = bumperMesh.geometry.vertices[VertexIndex].clone();
					var globalVertexB = localVertexB.applyMatrix4( bumperMesh.matrix );
					var directionVectorB = globalVertexB.sub( bumperMesh.position );
					var rayB = new THREE.Raycaster( positionBump, directionVectorB.clone().normalize() );// just one unit magnitude
					var collisionResultsB = rayB.intersectObjects( collidableMeshList );
					if ( collisionResultsB.length > 0 && collisionResultsB[0].distance < directionVectorB.length() )
						{
							// HERE THE COLLISION HAPPENS AND TODO PLACE
							//var oldColor = collisionResults[0].object.material.color ;
							collisionResultsB[0].object.material.color.setRGB(Math.random(),Math.random(),Math.random() ); 
							//above changes randomize the color of touched object
						 
						}
				}
					
				gatherInputData();	
				//transformBrick(setInputValuesRoboterta(inpoutValuesRobot)) ; // calling Open Roberta Generator.
				
				transformBrick(getRobotMotion(setInputValuesRoboterta(inpoutValuesRobot)));
                
				requestAnimationFrame(animateScene); 
				//console.log();
                 // Map the 3D scene down to the 2D screen (render the frame) 
                //renderScene(); 
				stats.update();
             } 
  
             /** 
              * Render the scene. Map the 3D world to the 2D screen.
              */ 
             function renderScene(){ 
                 renderer.render(scene, camera); 
             } 
			 
			 
			 function transformBrick(valuesBrick){
			 
				//inpoutValuesRobot = valuesBrick;
				//group.position.x += valuesBrick[POSITION_X_INDEX] ;
					group.position.x += valuesBrick[DELTA_X_INDEX];
				//group.position.y += valuesBrick[POSITION_Y_INDEX] ;
					group.position.y += valuesBrick[DELTA_Y_INDEX] ;
					//console.log("right wheel rotation "+getRigthWheelEncode()) ; to check encode
				if(valuesBrick[THETA_INDEX]!=0){ // change from ROTATION_Z_INDEX to THETA_INDEX because it comes from robotMotionHandler instead GeneratorRoberta
				
					group.rotation.z = valuesBrick[THETA_INDEX] ;
					//group.rotation.z += valuesBrick[ROTATION_Z_INDEX] ;
				}else{
					group.rotation.z = 0;
				
				}
				
				inpoutValuesRobot[LIGHT_COLOR_FLAG_INDEX] = valuesBrick[LIGHT_COLOR_FLAG_INDEX];
				inpoutValuesRobot[LIGHT_COLOR_INDEX] = valuesBrick[LIGHT_COLOR_INDEX];
				inpoutValuesRobot[POSITION_X_INDEX] = group.position.x ;
				inpoutValuesRobot[POSITION_Y_INDEX] = group.position.y ;
				inpoutValuesRobot[COLLISION_FLAG_INDEX] = true ;
				
				inpoutValuesRobot[ROTATION_Z_INDEX] = group.rotation.z ;
			 
			 }
			 
			 function gatherInputData(){
				inpoutValuesRobot[POSITION_X_INDEX] = group.position.x ;
				inpoutValuesRobot[POSITION_Y_INDEX] = group.position.y ;
				inpoutValuesRobot[COLLISION_FLAG_INDEX] = true ;
				
				inpoutValuesRobot[ROTATION_Z_INDEX] = group.rotation.z ;
				
				
				
			 }
			 
			 
			 
			 function decimal2Hex(d, padding) 
			 {
				var hex = Number(d).toString(16);
				padding = typeof (padding) === "undefined" || padding === null ? padding = 2 : padding;

				while (hex.length < padding) {
					hex = "0" + hex;
				}

				return hex;
			}
			
			
			
			function decimalToHex(d) {
					var hex = Number(d).toString(16);
				hex = "000000".substr(0, 6 - hex.length) + hex; 
				return hex;
			}
			
			
			
			
			
			
				
         </script> 
    </body> 
 </html>